---
# Copyright 2017, Rackspace US, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

- name: Pull systemd version
  command: "systemctl --version"
  changed_when: false
  register: systemd_version
  delegate_to: "{{ physical_host }}"
  tags:
    - skip_ansible_lint
    - always

- name: Set facts
  set_fact:
    nspawn_systemd_version: "{{ systemd_version.stdout_lines[0].split()[-1] }}"
  tags:
    - always

- name: Gather variables for each operating system
  include_vars: "{{ item }}"
  with_first_found:
    - "{{ hostvars[physical_host]['ansible_distribution'] | lower }}-{{ hostvars[physical_host]['ansible_distribution_version'] | lower }}.yml"
    - "{{ hostvars[physical_host]['ansible_distribution'] | lower }}-{{ hostvars[physical_host]['ansible_distribution_major_version'] | lower }}.yml"
    - "{{ hostvars[physical_host]['ansible_os_family'] | lower }}-{{ hostvars[physical_host]['ansible_distribution_major_version'] | lower }}.yml"
    - "{{ hostvars[physical_host]['ansible_distribution'] | lower }}.yml"
    - "{{ hostvars[physical_host]['ansible_os_family'] | lower }}.yml"
  tags:
    - always

- name: Escape quote container name
  command: "systemd-escape {{ inventory_hostname }}"
  changed_when: false
  register: systemd_escape
  delegate_to: "{{ physical_host }}"
  tags:
    - skip_ansible_lint
    - always

- name: Get container status
  command: machinectl status "{{ inventory_hostname }}"
  register: machinectl_container_status
  failed_when: false
  changed_when: false
  delegate_to: "{{ physical_host }}"

- name: Get container image status
  command: machinectl image-status "{{ inventory_hostname }}"
  register: machinectl_container_image_status
  failed_when: false
  changed_when: false
  delegate_to: "{{ physical_host }}"

- name: Get image status
  command: machinectl image-status "{{ container_image }}"
  register: machinectl_image_status
  failed_when: false
  changed_when: false
  delegate_to: "{{ physical_host }}"

- name: Fail if base image does not exist
  fail:
    msg: >
      The base container image "{{ container_image }}" does not exist. Check
      the name and try again.
  when:
    - machinectl_image_status.rc != 0

- name: Locate nspawn config
  stat:
    path: "/etc/systemd/nspawn/{{ inventory_hostname }}.nspawn"
  register: nspawn_config_exists
  delegate_to: "{{ physical_host }}"
  when:
    - nspawn_systemd_version | int > 219

- name: Slurp existing nspawn config
  slurp:
    src: "/etc/systemd/nspawn/{{ inventory_hostname }}.nspawn"
  register: nspawn_config
  changed_when: false
  delegate_to: "{{ physical_host }}"
  when:
    - nspawn_container_preserve_config | bool
    - nspawn_systemd_version | int > 219
    - nspawn_config_exists.stat.exists | bool

- name: Clone the base container image
  command: machinectl clone "{{ container_image }}" "{{ inventory_hostname }}"
  when:
    - machinectl_container_image_status.rc != 0
  register: machinectl_container_clone
  retries: 3
  delay: 2
  until: machinectl_container_clone is success
  delegate_to: "{{ physical_host }}"
  notify:
    - Container first boot
  tags:
    - skip_ansible_lint

- name: Container directories
  file:
    path: "{{ item }}"
    state: "directory"
  with_items:
    - "/openstack/{{ inventory_hostname }}"
    - "/openstack/backup/{{ inventory_hostname }}"
    - "/openstack/log/{{ inventory_hostname }}"
    - "/var/lib/machines/{{ inventory_hostname }}/etc/systemd/network"
    - "/var/lib/machines/{{ inventory_hostname }}/etc/systemd/nspawn"
    - "/var/lib/machines/{{ inventory_hostname }}/var/lib/dbus"
  delegate_to: "{{ physical_host }}"

- name: Container RO bind path cleanup
  file:
    path: "/var/lib/machines/{{ inventory_hostname }}{{ item.dest }}"
    state: "absent"
  with_items: "{{ nspawn_read_only_host_bindmount }}"
  delegate_to: "{{ physical_host }}"
  when:
    - machinectl_container_status.rc != 0

- name: Container inner service directories
  file:
    path: "/var/lib/machines/{{ inventory_hostname }}/{{ item.bind_dir_path }}"
    state: "directory"
  with_items: "{{ container_default_bind_mounts | union(container_bind_mounts | default([])) }}"
  delegate_to: "{{ physical_host }}"

- name: Container outer service directories
  file:
    path: "{{ item.mount_path }}"
    state: "directory"
  with_items: "{{ container_default_bind_mounts | union(container_bind_mounts | default([])) }}"
  delegate_to: "{{ physical_host }}"

# Check for the existance of an nspawn configuration file. If found slurp it up
# and use it as the base nspawn config file with the option to config template
# override.
- name: modern systemd block
  block:
    - name: Copy container config (new)
      config_template:
        content: "{{ nspawn_config.content | b64decode }}"
        dest: "/etc/systemd/nspawn/{{ inventory_hostname }}.nspawn"
        owner: "root"
        group: "root"
        mode: "0644"
        config_overrides: "{{ container_config_overrides | default({}) }}"
        config_type: "ini"
      delegate_to: "{{ physical_host }}"
      when:
        - nspawn_container_preserve_config | bool
        - nspawn_config_exists.stat.exists | bool

    # If no nspawn configuration file exists, create a new config file using the
    # default template.
    - name: Copy container config (new)
      config_template:
        src: templates/container_config.nspawn.j2
        dest: "/etc/systemd/nspawn/{{ inventory_hostname }}.nspawn"
        owner: "root"
        group: "root"
        mode: "0644"
        config_overrides: "{{ container_config_overrides | default({}) }}"
        config_type: "ini"
      delegate_to: "{{ physical_host }}"
      when:
        - not nspawn_container_preserve_config | bool or
          not nspawn_config_exists.stat.exists | bool
      notify:
        - Container first boot
  when:
    - nspawn_systemd_version | int > 219

- name: Copy container config (old)
  template:
    src: templates/container_config_old.nspawn.j2
    dest: "/etc/systemd/system/systemd-nspawn@{{ systemd_escape.stdout }}.service"
    owner: "root"
    group: "root"
    mode: "0644"
  register: container_config_old
  delegate_to: "{{ physical_host }}"
  when:
    - nspawn_systemd_version | int < 220
  notify:
    - Container first boot

- name: Generate machine-id
  command: "systemd-machine-id-setup --root=/var/lib/machines/{{ inventory_hostname }}"
  args:
    creates: "/var/lib/machines/{{ inventory_hostname }}/etc/machine-id"
  register: machineid_set
  retries: 3
  delay: 2
  until: machineid_set is success
  delegate_to: "{{ physical_host }}"
  tags:
    - skip_ansible_lint

- name: Create dbus machine-id
  copy:
    src: "/var/lib/machines/{{ inventory_hostname }}/etc/machine-id"
    dest: "/var/lib/machines/{{ inventory_hostname }}/var/lib/dbus/machine-id"
    mode: "0444"
    remote_src: "yes"
  remote_user: root
  delegate_to: "{{ physical_host }}"

- name: Start new container (enable)
  systemd:
    daemon_reload: yes
    name: "systemd-nspawn@{{ systemd_escape.stdout }}"
    state: "{{ (container_config_old | changed | default(false)) | ternary('restarted', 'started') }}"
    enabled: "{{ (nspawn_systemd_version | int > 219) | ternary('true', 'false') }}"
  register: machinectl_start
  retries: 5
  delay: 2
  until: machinectl_start is success
  delegate_to: "{{ physical_host }}"
  notify:
    - check connection

- name: Generate hostname
  command: >-
    hostnamectl --machine="{{ inventory_hostname }}" {{ item }} --pretty --static --transient
  with_items:
    - "set-hostname {{ inventory_hostname | replace('_', '-') }}.{{ container_domain }}"
    - "set-location {{ physical_host }}"
    - "set-chassis container"
    - "set-deployment {{ container_domain }}"
    - "set-icon-name container"
  register: hostnamectl_set
  retries: 3
  delay: 2
  until: hostnamectl_set is success
  delegate_to: "{{ physical_host }}"
  tags:
    - skip_ansible_lint

# This point the container is running. Delegation should no longer be required.
# ==============================================================================
- name: Create journal directory
  file:
    path: "/var/log/journal"
    state: "directory"

- name: Run the systemd-networkd role
  include_role:
    name: systemd_networkd
    private: true
  vars:
    systemd_interface_cleanup: false
    systemd_run_networkd: true
    systemd_resolved_available: "{{ nspawn_container_enable_resolved }}"
    systemd_resolved:
      DNS: "{{ hostvars[physical_host]['ansible_mv_' + nspawn_networks['nspawn_address']['bridge']]['ipv4']['address'] }}"
      Domains: "{{ container_domain }}"
    systemd_networks: |-
      {% set _networks = [] %}
      {% for _, value in (container_networks | combine(nspawn_networks)).items() %}
      {%   set _network = {'interface': value.interface | default('mv-mv-' + value.bridge.split('br-')[-1])} %}
      {%   if value.address is defined %}
      {%     set _ = _network.__setitem__('address', value.address) %}
      {%     if (value.netmask is defined) and (_network.address != 'dhcp') %}
      {%       set _ = _network.__setitem__('netmask', value.netmask) %}
      {%       set prefix = (value.address + '/' + value.netmask) | ipaddr('prefix') %}
      {%       set _ = _network.__setitem__('address', [value.address + '/' + prefix | string]) %}
      {%     endif %}
      {%   endif %}
      {%   set _ = _network.__setitem__('usedns', (value.usedns | default(true) | bool) | ternary('yes', 'no')) %}
      {%   set _ = _network.__setitem__('static_routes', value.static_routes | default([])) %}
      {%   if value.gateway is defined %}
      {%     set _ = _network.__setitem__('gateway', value.gateway) %}
      {%   endif %}
      {%   set _ = _network.__setitem__('mtu', value.mtu | default(1500 | string)) %}
      {%   set _ = _networks.append(_network) %}
      {% endfor %}
      {{ _networks | sort(attribute='interface') }}
  tags:
    - network-config

- name: Create resolved link
  file:
    src: "/var/run/systemd/resolve/resolv.conf"
    dest: "/etc/resolv.conf"
    force: true
    state: link
  when:
    - nspawn_container_enable_resolved | bool

# Some distros do not have access to systemd-resolved. If the option
# `nspawn_container_enable_resolved` is disabled this will ensure functionality
# in the absence of modern systemd.
- name: Legacy resolvers
  block:
    - name: Check resolv.conf
      stat:
        path: "/etc/resolv.conf"
      register: nspawn_resolv_conf

    - name: Remove resolv.conf link
      file:
        path: "/etc/resolv.conf"
        state: absent
      when:
        - nspawn_resolv_conf.stat.islnk is defined and
          nspawn_resolv_conf.stat.islnk

    - name: Place resolv.conf
      copy:
        content: |
          nameserver {{ hostvars[physical_host]['ansible_mv_' + nspawn_networks['nspawn_address']['bridge']]['ipv4']['address'] }}
          search {{ container_domain }}
        dest: "/etc/resolv.conf"
  when:
    - not nspawn_container_enable_resolved | bool

- name: Force all notified handlers now
  meta: flush_handlers

- name: (RE)Gather facts post setup
  setup: {}
